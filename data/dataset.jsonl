{"instruction": "Create a function to preprocess image data for a CNN.", "response": "```python\ndef preprocess_images(image_paths, target_size=(224, 224)):\n    \"\"\"Preprocess images for CNN input.\n    \n    Args:\n        image_paths: List of paths to images\n        target_size: Target size for resizing\n        \n    Returns:\n        Preprocessed images as numpy array\n    \"\"\"\n    from PIL import Image\n    import numpy as np\n    \n    processed_images = []\n    for img_path in image_paths:\n        # Load and resize image\n        img = Image.open(img_path).resize(target_size)\n        # Convert to array and normalize\n        img_array = np.array(img) / 255.0\n        processed_images.append(img_array)\n    \n    return np.array(processed_images)\n```"}
{"instruction": "Write code to train a random forest classifier.", "response": "```python\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\nimport pandas as pd\n\n# Load data\ndf = pd.read_csv('data.csv')\nX = df.drop('target', axis=1)\ny = df['target']\n\n# Split data\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Train model\nrf = RandomForestClassifier(n_estimators=100, random_state=42)\nrf.fit(X_train, y_train)\n\n# Evaluate\npredictions = rf.predict(X_test)\naccuracy = accuracy_score(y_test, predictions)\nprint(f'Accuracy: {accuracy:.4f}')\n```"}
{"instruction": "Create a function to perform text preprocessing for NLP tasks.", "response": "```python\ndef preprocess_text(texts, lower=True, remove_punctuation=True, remove_stopwords=True):\n    \"\"\"Preprocess text data for NLP.\n    \n    Args:\n        texts: List of text strings\n        lower: Whether to convert to lowercase\n        remove_punctuation: Whether to remove punctuation\n        remove_stopwords: Whether to remove stopwords\n        \n    Returns:\n        Preprocessed text\n    \"\"\"\n    import re\n    import nltk\n    from nltk.corpus import stopwords\n    \n    # Download required nltk resources\n    nltk.download('stopwords', quiet=True)\n    stop_words = set(stopwords.words('english'))\n    \n    processed_texts = []\n    for text in texts:\n        # Convert to lowercase\n        if lower:\n            text = text.lower()\n        \n        # Remove punctuation\n        if remove_punctuation:\n            text = re.sub(r'[^\\w\\s]', '', text)\n        \n        # Remove stopwords\n        if remove_stopwords:\n            words = text.split()\n            words = [word for word in words if word not in stop_words]\n            text = ' '.join(words)\n        \n        processed_texts.append(text)\n    \n    return processed_texts\n```"}
{"instruction": "Write a function to implement a simple neural network with PyTorch.", "response": "```python\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\n\nclass SimpleNN(nn.Module):\n    def __init__(self, input_size, hidden_size, output_size):\n        super(SimpleNN, self).__init__()\n        self.layer1 = nn.Linear(input_size, hidden_size)\n        self.relu = nn.ReLU()\n        self.layer2 = nn.Linear(hidden_size, output_size)\n    \n    def forward(self, x):\n        x = self.layer1(x)\n        x = self.relu(x)\n        x = self.layer2(x)\n        return x\n\ndef train_model(model, X_train, y_train, epochs=100, lr=0.01):\n    # Convert to tensors\n    X = torch.FloatTensor(X_train)\n    y = torch.FloatTensor(y_train)\n    \n    # Loss and optimizer\n    criterion = nn.MSELoss()\n    optimizer = optim.SGD(model.parameters(), lr=lr)\n    \n    # Training loop\n    for epoch in range(epochs):\n        # Forward pass\n        outputs = model(X)\n        loss = criterion(outputs, y)\n        \n        # Backward and optimize\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n        \n        if (epoch+1) % 10 == 0:\n            print(f'Epoch [{epoch+1}/{epochs}], Loss: {loss.item():.4f}')\n    \n    return model\n```"}
{"instruction": "Create a function to perform k-fold cross-validation with scikit-learn.", "response": "```python\nfrom sklearn.model_selection import KFold\nfrom sklearn.metrics import accuracy_score\nimport numpy as np\n\ndef perform_kfold_cv(model, X, y, n_splits=5):\n    \"\"\"Perform k-fold cross-validation.\n    \n    Args:\n        model: The machine learning model to evaluate\n        X: Feature matrix\n        y: Target vector\n        n_splits: Number of folds\n        \n    Returns:\n        Mean accuracy and std deviation\n    \"\"\"\n    kf = KFold(n_splits=n_splits, shuffle=True, random_state=42)\n    accuracies = []\n    \n    for train_idx, test_idx in kf.split(X):\n        # Split data\n        X_train, X_test = X[train_idx], X[test_idx]\n        y_train, y_test = y[train_idx], y[test_idx]\n        \n        # Train model\n        model.fit(X_train, y_train)\n        \n        # Evaluate\n        y_pred = model.predict(X_test)\n        fold_accuracy = accuracy_score(y_test, y_pred)\n        accuracies.append(fold_accuracy)\n        print(f'Fold accuracy: {fold_accuracy:.4f}')\n    \n    # Calculate statistics\n    mean_accuracy = np.mean(accuracies)\n    std_accuracy = np.std(accuracies)\n    \n    print(f'\\nMean accuracy: {mean_accuracy:.4f} (Â±{std_accuracy:.4f})')\n    return mean_accuracy, std_accuracy\n```"}
{"instruction": "Write a function to implement early stopping during model training.", "response": "```python\nclass EarlyStopping:\n    \"\"\"Early stopping to prevent overfitting.\n    \n    Args:\n        patience: Number of epochs to wait after min validation loss\n        min_delta: Minimum change in validation loss to qualify as improvement\n        restore_best_weights: Whether to restore model weights from the epoch with the best value\n    \"\"\"\n    def __init__(self, patience=5, min_delta=0, restore_best_weights=True):\n        self.patience = patience\n        self.min_delta = min_delta\n        self.restore_best_weights = restore_best_weights\n        self.counter = 0\n        self.best_loss = None\n        self.early_stop = False\n        self.best_weights = None\n    \n    def __call__(self, model, val_loss):\n        if self.best_loss is None:\n            self.best_loss = val_loss\n            if self.restore_best_weights:\n                self.best_weights = model.state_dict().copy()\n        elif self.best_loss - val_loss > self.min_delta:\n            self.best_loss = val_loss\n            self.counter = 0\n            if self.restore_best_weights:\n                self.best_weights = model.state_dict().copy()\n        else:\n            self.counter += 1\n            if self.counter >= self.patience:\n                self.early_stop = True\n                if self.restore_best_weights and self.best_weights is not None:\n                    model.load_state_dict(self.best_weights)\n                    \n        return self.early_stop\n```"}
